<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seminar: Shadowing in JavaScript</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple transition for slide content */
        .slide-content {
            transition: opacity 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl mx-auto">
        <!-- The style attribute here enforces the 16:9 aspect ratio -->
        <div id="presentation-container" class="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl overflow-hidden flex flex-col" style="aspect-ratio: 16 / 9;">
            
            <!-- Slide Content Area -->
            <div id="slide-content" class="flex-grow p-8 md:p-12 slide-content overflow-y-auto">
                <h1 id="slide-title" class="text-3xl md:text-4xl font-bold text-indigo-600 dark:text-indigo-400 mb-6"></h1>
                <div id="slide-body" class="text-lg md:text-xl space-y-4"></div>
            </div>

            <!-- Footer with Navigation and Counter -->
            <div class="bg-gray-50 dark:bg-gray-700 p-4 border-t border-gray-200 dark:border-gray-600 flex items-center justify-between flex-shrink-0">
                <span id="slide-counter" class="text-sm font-medium text-gray-600 dark:text-gray-300"></span>
                <div class="flex space-x-2">
                    <button id="prev-btn" class="px-4 py-2 bg-indigo-600 text-white rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors">
                        Previous
                    </button>
                    <button id="next-btn" class="px-4 py-2 bg-indigo-600 text-white rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors">
                        Next
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Preloaded video element, hidden by default -->
    <video id="preloaded-video" class="w-full h-full object-cover" src="https://res.cloudinary.com/dokuutvks/video/upload/videoplayback_5_qswhjc.mp4" autoplay muted loop playsinline style="display: none;"></video>

    <script>
        // --- Presentation Data ---
        const slides = [
            {
                title: "Shadowing in JavaScript",
                content: `<p class="text-2xl">Understanding Scope and Variable Overlapping</p><p class="mt-8 text-gray-500">A seminar on a core concept in JS.</p>`
            },
            {
                title: "What is Shadowing?",
                content: `
                    <ul class="list-disc pl-6 space-y-3">
                        <li>Shadowing occurs when a variable declared within a certain scope (e.g., a function or a block) has the same name as a variable in an outer scope.</li>
                        <li>When this happens, the inner variable "shadows" or hides the outer variable.</li>
                        <li>Accessing the variable name within the inner scope will refer to the inner variable.</li>
                    </ul>
                `
            },
            {
                title: "Example: Variable Shadowing",
                content: `
                    <p class="mb-4">An outer variable is shadowed by an inner variable within a specific block.</p>
                    <pre class="bg-gray-200 dark:bg-gray-900 p-4 rounded-lg text-sm h-full"><code class="language-js">
let pm = "Narendra Modi";

{
    let pm = "Rahul Gandhi";
    console.log("During voting: " + pm);
}

console.log("After result: " + pm);
                    </code></pre>
                `
            },
            {
                title: "Output & Explanation",
                content: `
                    <div class="flex flex-col md:flex-row gap-4 h-full">
                        <div class="w-full md:w-1/2 flex flex-col">
                            <p class="mb-2 text-base font-semibold flex-shrink-0">Console Output:</p>
                            <pre class="bg-gray-900 text-white p-4 rounded-lg text-sm flex-grow"><code class="language-console">
> During voting: Rahul Gandhi
> After result: Narendra Modi
                            </code></pre>
                        </div>
                        <div class="w-full md:w-1/2 flex flex-col">
                             <p class="mb-2 text-base font-semibold flex-shrink-0">Le Rahul Gandhi :</p>
                             <!-- This div is now a placeholder for the preloaded video -->
                             <div id="video-placeholder" class="w-full flex-grow rounded-lg overflow-hidden"></div>
                        </div>
                    </div>
                `
            },
            {
                title: "The Scope Chain",
                content: `
                    <ul class="list-disc pl-6 space-y-3">
                        <li>When you use a variable, JavaScript looks for it in the current scope.</li>
                        <li>If it doesn't find it, it looks in the outer scope.</li>
                        <li>This continues until it reaches the global scope.</li>
                        <li>Shadowing happens when the lookup finds a variable in a closer, inner scope first.</li>
                    </ul>
                `
            },
            {
                title: "Types of Shadowing",
                content: `
                    <ul class="list-disc pl-6 space-y-3">
                        <li><strong>Variable Shadowing:</strong> As seen in the previous example. Can happen with <code>let</code>, <code>const</code>, or <code>var</code>.</li>
                        <li><strong>Function Shadowing:</strong> A function in an inner scope can shadow a function in an outer scope.</li>
                        <li><strong>Parameter Shadowing:</strong> A function parameter can shadow a variable from an outer scope.</li>
                    </ul>
                `
            },
            {
                title: "Illegal Shadowing",
                content: `
                    <p class="mb-4">With <code>let</code> and <code>const</code>, you cannot re-declare the same variable in the same block scope.</p>
                    <pre class="bg-gray-200 dark:bg-gray-900 p-4 rounded-lg text-sm"><code class="language-js">
let color = "blue"; // Outer scope

// This is a new, standalone block scope
{
  let color = "red"; // This is legal, it shadows the outer 'color'.
  
  // let color = "green"; // This is ILLEGAL.
  // SyntaxError: 'color' has already been declared in this block.
}
                    </code></pre>
                `
            },
            {
                title: "Potential Pitfalls",
                content: `
                    <ul class="list-disc pl-6 space-y-3">
                        <li><strong>Unintended Behavior:</strong> Accidentally shadowing a variable can lead to bugs that are hard to track down. You might modify a local variable thinking you are changing the outer one.</li>
                        <li><strong>Code Readability:</strong> Using the same name for different variables can make the code confusing for other developers (and your future self!).</li>
                    </ul>
                `
            },
            {
                title: "Cons: Unintended Side Effects",
                content: `
                    <p class="mb-4">Shadowing can prevent you from modifying an outer variable when you intend to.</p>
                    <pre class="bg-gray-200 dark:bg-gray-900 p-4 rounded-lg text-sm"><code class="language-js">
let count = 100;

function updateCount() {
  let count = 0; // Shadows the outer 'count'
  count++; // This only changes the inner 'count' to 1
  console.log(count); // Prints 1
}

updateCount();
console.log(count); // Prints 100. The outer variable was not affected.
                    </code></pre>
                `
            },
            {
                title: "Cons: Reduced Readability",
                content: `
                    <ul class="list-disc pl-6 space-y-3">
                        <li><strong>Mental Overhead:</strong> Forces developers to constantly track which scope a variable belongs to. Is <code>user</code> the global user object or the local one?</li>
                        <li><strong>Code Obfuscation:</strong> Makes the code's intent less clear at a glance. It hides information, which is generally the opposite of what good code should do.</li>
                        <li><strong>Difficult Debugging:</strong> When a bug occurs, shadowed variables are a common source of confusion, making it harder to trace the flow of data.</li>
                    </ul>
                `
            },
            {
                title: "Pros: Is Shadowing Ever Good?",
                content: `
                    <p>Yes, but it should be intentional and clear. It's not inherently evil.</p>
                    <ul class="list-disc pl-6 space-y-3 mt-4">
                        <li><strong>Encapsulation:</strong> It allows inner scopes (like helper functions) to operate independently without worrying about variable name collisions from the outer scope.</li>
                        <li><strong>Convenience:</strong> Avoids the need to create slightly different variable names (e.g., <code>outerIndex</code>, <code>innerIndex</code>) when the context makes the scope obvious.</li>
                    </ul>
                `
            },
            {
                title: "Pros: Practical Use Cases",
                content: `
                    <p class="mb-4">Intentional shadowing is common and often necessary.</p>
                    <ul class="list-disc pl-6 space-y-3">
                        <li><strong>Function Parameters:</strong> The most accepted form. A parameter <code>id</code> naturally shadows any outer variable named <code>id</code>.</li>
                        <li><strong>Helper Functions:</strong> An inner function can safely reuse common variable names like <code>i</code>, <code>data</code>, or <code>item</code> without side effects.</li>
                    </ul>
                `
            },
            {
                title: "Best Practices",
                content: `
                    <ul class="list-disc pl-6 space-y-3">
                        <li><strong>Avoid Shadowing:</strong> When in doubt, don't. Use clear, descriptive, and unique variable names.</li>
                        <li><strong>Use <code>let</code> and <code>const</code>:</strong> They have block scope, which makes shadowing more predictable and less error-prone than <code>var</code>.</li>
                        <li><strong>Code Linters:</strong> Tools like ESLint can be configured to warn you about shadowed variables, helping you catch them early.</li>
                    </ul>
                `
            },
            {
                title: "Conclusion",
                content: `
                    <ul class="list-disc pl-6 space-y-3">
                        <li>Shadowing is a natural consequence of lexical scoping in JavaScript.</li>
                        <li>While it has some valid uses for encapsulation, it often leads to bugs and confusion.</li>
                        <li>Understanding the scope chain is key to mastering it.</li>
                        <li>Prioritize code clarity and maintainability above all.</li>
                    </ul>
                `
            },
            {
                title: "Thank You!",
                content: `<p class="text-3xl">Questions?</p>`
            }
        ];

        // --- Presentation Logic ---
        let currentSlide = 0;

        const slideTitleEl = document.getElementById('slide-title');
        const slideBodyEl = document.getElementById('slide-body');
        const slideContentEl = document.getElementById('slide-content');
        const slideCounterEl = document.getElementById('slide-counter');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        // Get a reference to the preloaded video element
        const preloadedVideo = document.getElementById('preloaded-video');

        function showSlide(index) {
            // Pause the video before doing anything else, to ensure it stops when leaving the slide.
            preloadedVideo.pause();
            
            // Fade out
            slideContentEl.style.opacity = 0;

            setTimeout(() => {
                const slide = slides[index];
                slideTitleEl.textContent = slide.title;
                slideBodyEl.innerHTML = slide.content;

                // If this is the slide with the video, find the placeholder, append the video, and play it.
                if (slide.title === "Output & Explanation") {
                    const placeholder = document.getElementById('video-placeholder');
                    if (placeholder) {
                        placeholder.appendChild(preloadedVideo);
                        preloadedVideo.style.display = 'block'; // Make it visible
                        // Explicitly play the video every time the slide is shown.
                        preloadedVideo.play().catch(error => {
                            // Autoplay was prevented. This can happen if the user hasn't interacted with the page yet.
                            // The video will still be visible and can be played manually if controls were enabled.
                            console.log("Autoplay prevented: ", error);
                        });
                    }
                }

                // Update counter
                slideCounterEl.textContent = `Slide ${index + 1} of ${slides.length}`;

                // Update button states
                prevBtn.disabled = index === 0;
                nextBtn.disabled = index === slides.length - 1;
                
                // Fade in
                slideContentEl.style.opacity = 1;
            }, 300); // Match timeout with transition duration
        }

        function changeSlide(n) {
            currentSlide += n;
            if (currentSlide >= 0 && currentSlide < slides.length) {
                showSlide(currentSlide);
            } else {
                // reset to valid range
                currentSlide = Math.max(0, Math.min(slides.length - 1, currentSlide));
            }
        }

        // Event Listeners
        prevBtn.addEventListener('click', () => changeSlide(-1));
        nextBtn.addEventListener('click', () => changeSlide(1));
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') {
                if(currentSlide < slides.length - 1) changeSlide(1);
            } else if (e.key === 'ArrowLeft') {
                if(currentSlide > 0) changeSlide(-1);
            }
        });

        // Initial slide load
        window.onload = () => {
            showSlide(currentSlide);
        };
    </script>
</body>
</html>
